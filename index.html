<!DOCTYPE html>
<html lang="en"><head>

<script class="injected-ffc2e83d85">
(function(){'use strict';function q(b){var c=0;return function(){return c<b.length?{done:!1,value:b[c++]}:{done:!0}}}function t(b){var c=typeof Symbol!="undefined"&&Symbol.iterator&&b[Symbol.iterator];if(c)return c.call(b);if(typeof b.length=="number")return{next:q(b)};throw Error(String(b)+" is not an iterable or ArrayLike");}var u=typeof Object.defineProperties=="function"?Object.defineProperty:function(b,c,g){if(b==Array.prototype||b==Object.prototype)return b;b[c]=g.value;return b};
function v(b){b=["object"==typeof globalThis&&globalThis,b,"object"==typeof window&&window,"object"==typeof self&&self,"object"==typeof global&&global];for(var c=0;c<b.length;++c){var g=b[c];if(g&&g.Math==Math)return g}throw Error("Cannot find global object");}var w=v(this);function x(b,c){if(c)a:{var g=w;b=b.split(".");for(var h=0;h<b.length-1;h++){var l=b[h];if(!(l in g))break a;g=g[l]}b=b[b.length-1];h=g[b];c=c(h);c!=h&&c!=null&&u(g,b,{configurable:!0,writable:!0,value:c})}}
function y(){this.j=!1;this.g=null;this.u=void 0;this.h=1;this.v=this.l=0;this.i=null}function z(b){if(b.j)throw new TypeError("Generator is already running");b.j=!0}y.prototype.o=function(b){this.u=b};function A(b,c){b.i={I:c,J:!0};b.h=b.l||b.v}y.prototype.return=function(b){this.i={return:b};this.h=this.v};function B(b){this.g=new y;this.h=b}function E(b,c){z(b.g);var g=b.g.g;if(g)return F(b,"return"in g?g["return"]:function(h){return{value:h,done:!0}},c,b.g.return);b.g.return(c);return G(b)}
function F(b,c,g,h){try{var l=c.call(b.g.g,g);if(!(l instanceof Object))throw new TypeError("Iterator result "+l+" is not an object");if(!l.done)return b.g.j=!1,l;var m=l.value}catch(f){return b.g.g=null,A(b.g,f),G(b)}b.g.g=null;h.call(b.g,m);return G(b)}function G(b){for(;b.g.h;)try{var c=b.h(b.g);if(c)return b.g.j=!1,{value:c.value,done:!1}}catch(g){b.g.u=void 0,A(b.g,g)}b.g.j=!1;if(b.g.i){c=b.g.i;b.g.i=null;if(c.J)throw c.I;return{value:c.return,done:!0}}return{value:void 0,done:!0}}
function H(b){this.next=function(c){z(b.g);b.g.g?c=F(b,b.g.g.next,c,b.g.o):(b.g.o(c),c=G(b));return c};this.throw=function(c){z(b.g);b.g.g?c=F(b,b.g.g["throw"],c,b.g.o):(A(b.g,c),c=G(b));return c};this.return=function(c){return E(b,c)};this[Symbol.iterator]=function(){return this}}function I(b){function c(h){return b.next(h)}function g(h){return b.throw(h)}return new Promise(function(h,l){function m(f){f.done?h(f.value):Promise.resolve(f.value).then(c,g).then(m,l)}m(b.next())})}
x("Symbol",function(b){function c(m){if(this instanceof c)throw new TypeError("Symbol is not a constructor");return new g(h+(m||"")+"_"+l++,m)}function g(m,f){this.g=m;u(this,"description",{configurable:!0,writable:!0,value:f})}if(b)return b;g.prototype.toString=function(){return this.g};var h="jscomp_symbol_"+(Math.random()*1E9>>>0)+"_",l=0;return c});
x("Symbol.iterator",function(b){if(b)return b;b=Symbol("Symbol.iterator");u(Array.prototype,b,{configurable:!0,writable:!0,value:function(){return J(q(this))}});return b});function J(b){b={next:b};b[Symbol.iterator]=function(){return this};return b}
x("Promise",function(b){function c(f){this.h=0;this.i=void 0;this.g=[];this.u=!1;var a=this.j();try{f(a.resolve,a.reject)}catch(d){a.reject(d)}}function g(){this.g=null}function h(f){return f instanceof c?f:new c(function(a){a(f)})}if(b)return b;g.prototype.h=function(f){if(this.g==null){this.g=[];var a=this;this.i(function(){a.l()})}this.g.push(f)};var l=w.setTimeout;g.prototype.i=function(f){l(f,0)};g.prototype.l=function(){for(;this.g&&this.g.length;){var f=this.g;this.g=[];for(var a=0;a<f.length;++a){var d=
f[a];f[a]=null;try{d()}catch(e){this.j(e)}}}this.g=null};g.prototype.j=function(f){this.i(function(){throw f;})};c.prototype.j=function(){function f(e){return function(k){d||(d=!0,e.call(a,k))}}var a=this,d=!1;return{resolve:f(this.D),reject:f(this.l)}};c.prototype.D=function(f){if(f===this)this.l(new TypeError("A Promise cannot resolve to itself"));else if(f instanceof c)this.G(f);else{a:switch(typeof f){case "object":var a=f!=null;break a;case "function":a=!0;break a;default:a=!1}a?this.C(f):this.o(f)}};
c.prototype.C=function(f){var a=void 0;try{a=f.then}catch(d){this.l(d);return}typeof a=="function"?this.H(a,f):this.o(f)};c.prototype.l=function(f){this.v(2,f)};c.prototype.o=function(f){this.v(1,f)};c.prototype.v=function(f,a){if(this.h!=0)throw Error("Cannot settle("+f+", "+a+"): Promise already settled in state"+this.h);this.h=f;this.i=a;this.h===2&&this.F();this.K()};c.prototype.F=function(){var f=this;l(function(){if(f.B()){var a=w.console;typeof a!=="undefined"&&a.error(f.i)}},1)};c.prototype.B=
function(){if(this.u)return!1;var f=w.CustomEvent,a=w.Event,d=w.dispatchEvent;if(typeof d==="undefined")return!0;typeof f==="function"?f=new f("unhandledrejection",{cancelable:!0}):typeof a==="function"?f=new a("unhandledrejection",{cancelable:!0}):(f=w.document.createEvent("CustomEvent"),f.initCustomEvent("unhandledrejection",!1,!0,f));f.promise=this;f.reason=this.i;return d(f)};c.prototype.K=function(){if(this.g!=null){for(var f=0;f<this.g.length;++f)m.h(this.g[f]);this.g=null}};var m=new g;c.prototype.G=
function(f){var a=this.j();f.A(a.resolve,a.reject)};c.prototype.H=function(f,a){var d=this.j();try{f.call(a,d.resolve,d.reject)}catch(e){d.reject(e)}};c.prototype.then=function(f,a){function d(n,r){return typeof n=="function"?function(C){try{e(n(C))}catch(D){k(D)}}:r}var e,k,p=new c(function(n,r){e=n;k=r});this.A(d(f,e),d(a,k));return p};c.prototype.catch=function(f){return this.then(void 0,f)};c.prototype.A=function(f,a){function d(){switch(e.h){case 1:f(e.i);break;case 2:a(e.i);break;default:throw Error("Unexpected state: "+
e.h);}}var e=this;this.g==null?m.h(d):this.g.push(d);this.u=!0};c.resolve=h;c.reject=function(f){return new c(function(a,d){d(f)})};c.race=function(f){return new c(function(a,d){for(var e=t(f),k=e.next();!k.done;k=e.next())h(k.value).A(a,d)})};c.all=function(f){var a=t(f),d=a.next();return d.done?h([]):new c(function(e,k){function p(C){return function(D){n[C]=D;r--;r==0&&e(n)}}var n=[],r=0;do n.push(void 0),r++,h(d.value).A(p(n.length-1),k),d=a.next();while(!d.done)})};return c});
function K(b,c){return Object.prototype.hasOwnProperty.call(b,c)}x("Object.is",function(b){return b?b:function(c,g){return c===g?c!==0||1/c===1/g:c!==c&&g!==g}});x("Array.prototype.includes",function(b){return b?b:function(c,g){var h=this;h instanceof String&&(h=String(h));var l=h.length;g=g||0;for(g<0&&(g=Math.max(g+l,0));g<l;g++){var m=h[g];if(m===c||Object.is(m,c))return!0}return!1}});
x("String.prototype.includes",function(b){return b?b:function(c,g){if(this==null)throw new TypeError("The 'this' value for String.prototype.includes must not be null or undefined");if(c instanceof RegExp)throw new TypeError("First argument to String.prototype.includes must not be a regular expression");return this.indexOf(c,g||0)!==-1}});
x("WeakMap",function(b){function c(d){this.g=(a+=Math.random()+1).toString();if(d){d=t(d);for(var e;!(e=d.next()).done;)e=e.value,this.set(e[0],e[1])}}function g(){}function h(d){var e=typeof d;return e==="object"&&d!==null||e==="function"}function l(d){if(!K(d,f)){var e=new g;u(d,f,{value:e})}}function m(d){var e=Object[d];e&&(Object[d]=function(k){if(k instanceof g)return k;Object.isExtensible(k)&&l(k);return e(k)})}if(function(){if(!b||!Object.seal)return!1;try{var d=Object.seal({}),e=Object.seal({}),
k=new b([[d,2],[e,3]]);if(k.get(d)!=2||k.get(e)!=3)return!1;k.delete(d);k.set(e,4);return!k.has(d)&&k.get(e)==4}catch(p){return!1}}())return b;var f="$jscomp_hidden_"+Math.random();m("freeze");m("preventExtensions");m("seal");var a=0;c.prototype.set=function(d,e){if(!h(d))throw Error("Invalid WeakMap key");l(d);if(!K(d,f))throw Error("WeakMap key fail: "+d);d[f][this.g]=e;return this};c.prototype.get=function(d){return h(d)&&K(d,f)?d[f][this.g]:void 0};c.prototype.has=function(d){return h(d)&&K(d,
f)&&K(d[f],this.g)};c.prototype.delete=function(d){return h(d)&&K(d,f)&&K(d[f],this.g)?delete d[f][this.g]:!1};return c});
x("Map",function(b){function c(){var a={};return a.m=a.next=a.head=a}function g(a,d){var e=a[1];return J(function(){if(e){for(;e.head!=a[1];)e=e.m;for(;e.next!=e.head;)return e=e.next,{done:!1,value:d(e)};e=null}return{done:!0,value:void 0}})}function h(a,d){var e=d&&typeof d;e=="object"||e=="function"?m.has(d)?e=m.get(d):(e=""+ ++f,m.set(d,e)):e="p_"+d;var k=a[0][e];if(k&&K(a[0],e))for(a=0;a<k.length;a++){var p=k[a];if(d!==d&&p.key!==p.key||d===p.key)return{id:e,list:k,index:a,entry:p}}return{id:e,
list:k,index:-1,entry:void 0}}function l(a){this[0]={};this[1]=c();this.size=0;if(a){a=t(a);for(var d;!(d=a.next()).done;)d=d.value,this.set(d[0],d[1])}}if(function(){if(!b||typeof b!="function"||!b.prototype.entries||typeof Object.seal!="function")return!1;try{var a=Object.seal({x:4}),d=new b(t([[a,"s"]]));if(d.get(a)!="s"||d.size!=1||d.get({x:4})||d.set({x:4},"t")!=d||d.size!=2)return!1;var e=d.entries(),k=e.next();if(k.done||k.value[0]!=a||k.value[1]!="s")return!1;k=e.next();return k.done||k.value[0].x!=
4||k.value[1]!="t"||!e.next().done?!1:!0}catch(p){return!1}}())return b;var m=new WeakMap;l.prototype.set=function(a,d){a=a===0?0:a;var e=h(this,a);e.list||(e.list=this[0][e.id]=[]);e.entry?e.entry.value=d:(e.entry={next:this[1],m:this[1].m,head:this[1],key:a,value:d},e.list.push(e.entry),this[1].m.next=e.entry,this[1].m=e.entry,this.size++);return this};l.prototype.delete=function(a){a=h(this,a);return a.entry&&a.list?(a.list.splice(a.index,1),a.list.length||delete this[0][a.id],a.entry.m.next=a.entry.next,
a.entry.next.m=a.entry.m,a.entry.head=null,this.size--,!0):!1};l.prototype.clear=function(){this[0]={};this[1]=this[1].m=c();this.size=0};l.prototype.has=function(a){return!!h(this,a).entry};l.prototype.get=function(a){return(a=h(this,a).entry)&&a.value};l.prototype.entries=function(){return g(this,function(a){return[a.key,a.value]})};l.prototype.keys=function(){return g(this,function(a){return a.key})};l.prototype.values=function(){return g(this,function(a){return a.value})};l.prototype.forEach=
function(a,d){for(var e=this.entries(),k;!(k=e.next()).done;)k=k.value,a.call(d,k[1],k[0],this)};l.prototype[Symbol.iterator]=l.prototype.entries;var f=0;return l});
x("Set",function(b){function c(g){this.g=new Map;if(g){g=t(g);for(var h;!(h=g.next()).done;)this.add(h.value)}this.size=this.g.size}if(function(){if(!b||typeof b!="function"||!b.prototype.entries||typeof Object.seal!="function")return!1;try{var g=Object.seal({x:4}),h=new b(t([g]));if(!h.has(g)||h.size!=1||h.add(g)!=h||h.size!=1||h.add({x:4})!=h||h.size!=2)return!1;var l=h.entries(),m=l.next();if(m.done||m.value[0]!=g||m.value[1]!=g)return!1;m=l.next();return m.done||m.value[0]==g||m.value[0].x!=4||
m.value[1]!=m.value[0]?!1:l.next().done}catch(f){return!1}}())return b;c.prototype.add=function(g){g=g===0?0:g;this.g.set(g,g);this.size=this.g.size;return this};c.prototype.delete=function(g){g=this.g.delete(g);this.size=this.g.size;return g};c.prototype.clear=function(){this.g.clear();this.size=0};c.prototype.has=function(g){return this.g.has(g)};c.prototype.entries=function(){return this.g.entries()};c.prototype.values=function(){return this.g.values()};c.prototype.keys=c.prototype.values;c.prototype[Symbol.iterator]=
c.prototype.values;c.prototype.forEach=function(g,h){var l=this;this.g.forEach(function(m){return g.call(h,m,m,l)})};return c});(function(){function b(){return m?Promise.resolve(m):f?f:f=fetch("https://www.gstatic.com/bard-maui/resources/material-design-icon-names.804824289.json").then(function(a){if(!a.ok)throw Error("HTTP error! status: "+a.status+" fetching https://www.gstatic.com/bard-maui/resources/material-design-icon-names.804824289.json");return a.json()}).then(function(a){if(!Array.isArray(a))throw new TypeError("Fetched icon names from https://www.gstatic.com/bard-maui/resources/material-design-icon-names.804824289.json is not an array.");
return m=a}).catch(function(a){console.error("IconChecker: Failed to load valid icon names from https://www.gstatic.com/bard-maui/resources/material-design-icon-names.804824289.json.",a);f=null;throw a;})}function c(a){var d,e,k,p;return I(new H(new B(function(n){switch(n.h){case 1:d=(a.textContent||"").trim();if(!d||a.classList.contains("js-replaced-missing-icon")&&d==="radio_button_unchecked")return n.return();e=window.getComputedStyle(a);if(e.display==="none"||e.visibility==="hidden")return n.return();
n.l=2;var r=b();n.h=4;return{value:r};case 4:k=n.u;n.h=3;n.l=0;break;case 2:return n.l=0,n.i=null,console.warn('IconChecker: Skipping check for icon "'+d+'" as valid names could not be loaded.'),n.return();case 3:(p=k.includes(d))?a.classList.contains("js-replaced-missing-icon")&&a.classList.remove("js-replaced-missing-icon"):d==="radio_button_unchecked"&&a.classList.contains("js-replaced-missing-icon")||(a.textContent="radio_button_unchecked",a.classList.add("js-replaced-missing-icon")),n.h=0}})))}
function g(a){a=a===void 0?document.body:a;a.querySelectorAll(l).forEach(function(d){c(d)})}function h(){b().catch(function(){});document.fonts.ready.then(function(){requestAnimationFrame(function(){g(document.body);(new MutationObserver(function(a){var d=new Set;a=t(a);for(var e=a.next();!e.done;e=a.next())if(e=e.value,e.type==="childList")e.addedNodes.forEach(function(p){p.nodeType===Node.ELEMENT_NODE&&(p.matches(l)&&d.add(p),p.querySelectorAll(l).forEach(function(n){d.add(n)}))});else if(e.type===
"attributes"&&e.attributeName==="class"){var k=e.target;e.target.nodeType===Node.ELEMENT_NODE&&k.matches(l)&&d.add(k)}else e.type==="characterData"&&e.target.parentNode&&(e=e.target.parentNode,e.nodeType===Node.ELEMENT_NODE&&e.matches(l)&&d.add(e));d.size>0&&setTimeout(function(){d.forEach(function(p){c(p)})},500)})).observe(document.body,{childList:!0,subtree:!0,attributes:!0,attributeFilter:["class"],characterData:!0})})}).catch(function(a){console.error("IconChecker: Font loading error. Scanning icons anyway.",
a);requestAnimationFrame(function(){g(document.body)})})}var l=["material-icons","material-symbols-outlined","material-symbols-rounded","material-symbols-sharp"].map(function(a){return"."+a}).join(","),m=null,f=null;document.readyState==="loading"?document.addEventListener("DOMContentLoaded",function(){h()}):h()})();}).call(this);


</script>


<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1.0" name="viewport">
<title>Canvases</title>

<!-- Favicons -->
<link rel="icon" type="image/png" href="favicon/favicon-96x96.png" sizes="96x96" />
<link rel="icon" type="image/svg+xml" href="favicon/favicon.svg" />
<link rel="shortcut icon" href="favicon/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="favicon/apple-touch-icon.png" />
<meta name="apple-mobile-web-app-title" content="Canvases" />
<link rel="manifest" href="favicon/site.webmanifest" />

<!-- Tailwind CSS -->
<script src="https://cdn.tailwindcss.com"></script>
<!-- Monaco Editor Loader -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.45.0/min/vs/loader.min.js"></script>
<script>
    tailwind.config = {
        darkMode: 'class',
        theme: {
            extend: {
                colors: {
                    canvas: { light: '#f4fbfd', dark: '#0c1214' }, // Subtle cyan tinge
                }
            }
        }
    }
</script>
<!-- Material Symbols -->
<link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,0,0" rel="stylesheet">
<style>
    /* Custom Scrollbar */
    ::-webkit-scrollbar { width: 6px; height: 6px; }
    ::-webkit-scrollbar-thumb { background: #94a3b8; border-radius: 3px; }
    .dark ::-webkit-scrollbar-thumb { background: #52525b; }

    /* Canvas Background */
    .dot-bg {
        background-image: radial-gradient(#cbd5e1 1px, transparent 1px);
        background-size: 24px 24px;
        width: 100%;
        height: 100%;
        position: fixed;
    }
    .dark .dot-bg {
        background-image: radial-gradient(#27272a 1px, transparent 1px);
    }
    
    /* Hide Dots */
    body.hide-dots .dot-bg {
        background-image: none !important;
    }

    /* Interaction */
    #canvas-container { touch-action: none; cursor: grab; }
    #canvas-container.grabbing { cursor: grabbing; }

    /* Node Architecture */
    .canvas-node {
        position: absolute;
        transform-origin: 0 0;
        will-change: transform, left, top;
        display: flex;
        flex-direction: column;
    }

    /* Z-Index Layering */
    .canvas-node.type-label { z-index: 5; }
    .canvas-node.type-snippet { z-index: 20; }
    .canvas-node.selected { z-index: 50; } 

    /* --- Snippet Styling --- */
    .node-header {
        position: absolute;
        bottom: 100%;
        left: 0;
        width: 100%;
        padding-bottom: 10px;
        display: flex;
        justify-content: space-between;
        align-items: flex-end;
        pointer-events: none;
        z-index: 30;
    }
    .node-header > * { pointer-events: auto; }

    /* Frame Titles */
    .node-title {
        font-family: monospace;
        font-weight: 800;
        font-size: 1.5rem; 
        padding: 4px 0;
        cursor: move;
        color: var(--title-color, #64748b);
        transition: color 0.2s;
        text-shadow: 0 0 20px rgba(255,255,255,1);
        white-space: nowrap;
        letter-spacing: -0.03em;
        line-height: 1;
    }
    .dark .node-title { text-shadow: 0 0 20px rgba(0,0,0,1); }

    .node-actions {
        display: flex;
        gap: 8px;
        margin-left: auto;
        opacity: 0;
        transition: opacity 0.2s;
    }
    .canvas-node:hover .node-actions {
        opacity: 1;
    }

    /* Action Buttons */
    .action-btn {
        background: white;
        border: 1px solid #e2e8f0;
        padding: 10px; 
        border-radius: 10px;
        box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1);
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s;
        color: #475569;
    }
    .dark .action-btn {
        background: #18181b;
        border-color: #27272a;
        color: #94a3b8;
    }
    .action-btn:hover { background: #f1f5f9; color: #0f172a; transform: translateY(-2px); }
    .dark .action-btn:hover { background: #27272a; color: #f8fafc; }
    .action-btn.delete:hover { background: #fee2e2; color: #ef4444; border-color: #fecaca; }
    .dark .action-btn.delete:hover { background: #450a0a; color: #f87171; border-color: #7f1d1d; }
    
    .action-btn .material-symbols-outlined { font-size: 24px; }

    /* Preview Wrapper */
    .node-preview-wrapper {
        position: relative;
        background: white;
        border-radius: 1rem;
        box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
        overflow: hidden;
        border: 1px solid #e2e8f0;
        transition: box-shadow 0.2s;
        flex-shrink: 0; 
        z-index: 10;
        width: 100%; height: 100%;
    }
    .dark .node-preview-wrapper { background: #18181b; border-color: #27272a; }
    .canvas-node.selected .node-preview-wrapper {
        box-shadow: 0 0 0 4px #3b82f6, 0 25px 50px -12px rgba(0, 0, 0, 0.25);
    }

    /* --- Variables (Collapsible Settings) --- */
    .node-vars {
        width: 100%;
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(16px);
        border: 1px solid #e2e8f0;
        border-top: none;
        padding: 16px; 
        box-sizing: border-box;
        margin-top: -1px;
        position: relative;
        z-index: 35;
        display: none; 
    }
    .dark .node-vars { background: rgba(24, 24, 27, 0.95); border-color: #27272a; }
    .canvas-node.vars-expanded .node-vars { display: block; }

    .node-vars .var-label { font-size: 0.9rem; font-weight: 600; }
    .node-vars input, .node-vars .hex-text, .node-vars .scrub-input { font-size: 0.9rem; }
    .node-vars input[type=color] { width: 28px; height: 28px; }

    /* --- Prompt (Bottom Hover) --- */
    .node-prompt {
        width: 100%;
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(16px);
        border: 1px solid #e2e8f0;
        border-top: none;
        border-radius: 0 0 1rem 1rem;
        padding: 12px;
        box-sizing: border-box;
        margin-top: -1px;
        position: relative;
        z-index: 35;
        opacity: 0;
        visibility: hidden;
        transform: translateY(-8px);
        transition: opacity 0.2s ease, transform 0.2s ease;
    }
    .dark .node-prompt { background: rgba(24, 24, 27, 0.95); border-color: #27272a; }
    .node-prompt textarea { font-size: 0.95rem; line-height: 1.5; height: 5rem; }

    /* View Toggles */
    body.show-details-always .node-prompt {
        opacity: 1 !important;
        visibility: visible !important;
        transform: translateY(0) !important;
    }
    body.details-on-hover .canvas-node:hover .node-prompt {
        opacity: 1;
        visibility: visible;
        transform: translateY(0);
    }

    /* --- Label Styling --- */
    .type-label {
        border-radius: 2rem;
        backdrop-filter: blur(30px) saturate(180%);
        box-shadow: 0 4px 6px -1px rgba(0,0,0,0.05);
    }
    
    .label-header {
        padding: 24px 32px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        width: 100%;
        box-sizing: border-box;
    }

    .label-title {
        font-family: sans-serif;
        font-weight: 900;
        font-size: 3.5rem; 
        background: transparent;
        border: none;
        outline: none;
        width: 100%;
        cursor: text;
        line-height: 1;
        letter-spacing: -0.02em;
    }

    .label-controls { display: flex; gap: 16px; align-items: center; }

    .color-swatch-wrapper {
        position: relative;
        width: 48px; height: 48px; 
        opacity: 0; 
        transition: opacity 0.2s;
    }
    .type-label:hover .color-swatch-wrapper { opacity: 1; }

    .color-swatch {
        width: 100%; height: 100%;
        border-radius: 50%;
        border: 4px solid white;
        box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        cursor: pointer;
        padding: 0;
        -webkit-appearance: none;
    }
    .color-swatch::-webkit-color-swatch-wrapper { padding: 0; }
    .color-swatch::-webkit-color-swatch { border: none; border-radius: 50%; }

    .label-del .material-symbols-outlined { font-size: 28px; }

    /* Scrubbing Input */
    .scrub-input {
        cursor: ew-resize;
        color: #3b82f6;
        font-weight: bold;
    }
    .scrub-input:hover { background-color: rgba(59, 130, 246, 0.1); border-radius: 2px; }

    /* Resizer */
    .node-resizer {
        position: absolute;
        bottom: 0; right: 0; width: 40px; height: 40px;
        cursor: nwse-resize; z-index: 60;
        background: linear-gradient(135deg, transparent 50%, #94a3b8 50%);
        border-bottom-right-radius: 1rem;
        opacity: 0; transition: opacity 0.2s;
        pointer-events: auto;
    }
    .canvas-node:hover .node-resizer { opacity: 0.8; }

    .iframe-scaler { transform-origin: 0 0; width: 100%; height: 100%; }
</style>
<style>*, ::before, ::after{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgb(59 130 246 / 0.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }::backdrop{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgb(59 130 246 / 0.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }/* ! tailwindcss v3.4.17 | MIT License | https://tailwindcss.com */*,::after,::before{box-sizing:border-box;border-width:0;border-style:solid;border-color:#e5e7eb}::after,::before{--tw-content:''}:host,html{line-height:1.5;-webkit-text-size-adjust:100%;-moz-tab-size:4;tab-size:4;font-family:ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";font-feature-settings:normal;font-variation-settings:normal;-webkit-tap-highlight-color:transparent}body{margin:0;line-height:inherit}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,pre,samp{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;font-feature-settings:normal;font-variation-settings:normal;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}button,input,optgroup,select,textarea{font-family:inherit;font-feature-settings:inherit;font-variation-settings:inherit;font-size:100%;font-weight:inherit;line-height:inherit;letter-spacing:inherit;color:inherit;margin:0;padding:0}button,select{text-transform:none}button,input:where([type=button]),input:where([type=reset]),input:where([type=submit]){-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dd,dl,figure,h1,h2,h3,h4,h5,h6,hr,p,pre{margin:0}fieldset{margin:0;padding:0}legend{padding:0}menu,ol,ul{list-style:none;margin:0;padding:0}dialog{padding:0}textarea{resize:vertical}input::placeholder,textarea::placeholder{opacity:1;color:#9ca3af}[role=button],button{cursor:pointer}:disabled{cursor:default}audio,canvas,embed,iframe,img,object,svg,video{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}[hidden]:where(:not([hidden=until-found])){display:none}.pointer-events-none{pointer-events:none}.fixed{position:fixed}.absolute{position:absolute}.relative{position:relative}.inset-0{inset:0px}.bottom-32{bottom:8rem}.bottom-8{bottom:2rem}.left-0{left:0px}.left-1\/2{left:50%}.right-8{right:2rem}.top-0{top:0px}.top-6{top:1.5rem}.z-50{z-index:50}.z-\[100\]{z-index:100}.z-\[200\]{z-index:200}.z-\[60\]{z-index:60}.mx-1{margin-left:0.25rem;margin-right:0.25rem}.mb-2{margin-bottom:0.5rem}.mb-6{margin-bottom:1.5rem}.flex{display:flex}.hidden{display:none}.h-8{height:2rem}.h-full{height:100%}.h-screen{height:100vh}.w-12{width:3rem}.w-48{width:12rem}.w-full{width:100%}.w-px{width:1px}.w-screen{width:100vw}.max-w-sm{max-width:24rem}.flex-1{flex:1 1 0%}.origin-top-left{transform-origin:top left}.-translate-x-1\/2{--tw-translate-x:-50%;transform:translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.translate-y-4{--tw-translate-y:1rem;transform:translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.scale-100{--tw-scale-x:1;--tw-scale-y:1;transform:translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.transform{transform:translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.flex-col{flex-direction:column}.items-center{align-items:center}.justify-end{justify-content:flex-end}.justify-center{justify-content:center}.justify-between{justify-content:space-between}.gap-2{gap:0.5rem}.gap-3{gap:0.75rem}.gap-4{gap:1rem}.overflow-hidden{overflow:hidden}.whitespace-nowrap{white-space:nowrap}.rounded-2xl{border-radius:1rem}.rounded-3xl{border-radius:1.5rem}.rounded-full{border-radius:9999px}.rounded-lg{border-radius:0.5rem}.rounded-xl{border-radius:0.75rem}.border{border-width:1px}.border-0{border-width:0px}.border-b{border-bottom-width:1px}.border-slate-200{--tw-border-opacity:1;border-color:rgb(226 232 240 / var(--tw-border-opacity, 1))}.bg-black\/50{background-color:rgb(0 0 0 / 0.5)}.bg-black\/80{background-color:rgb(0 0 0 / 0.8)}.bg-canvas-light{--tw-bg-opacity:1;background-color:rgb(248 250 252 / var(--tw-bg-opacity, 1))}.bg-red-500{--tw-bg-opacity:1;background-color:rgb(239 68 68 / var(--tw-bg-opacity, 1))}.bg-slate-100{--tw-bg-opacity:1;background-color:rgb(241 245 249 / var(--tw-bg-opacity, 1))}.bg-slate-200{--tw-bg-opacity:1;background-color:rgb(226 232 240 / var(--tw-bg-opacity, 1))}.bg-slate-800{--tw-bg-opacity:1;background-color:rgb(30 41 59 / var(--tw-bg-opacity, 1))}.bg-white{--tw-bg-opacity:1;background-color:rgb(255 255 255 / var(--tw-bg-opacity, 1))}.bg-white\/95{background-color:rgb(255 255 255 / 0.95)}.p-2{padding:0.5rem}.p-3{padding:0.75rem}.p-4{padding:1rem}.p-6{padding:1.5rem}.p-8{padding:2rem}.px-4{padding-left:1rem;padding-right:1rem}.px-5{padding-left:1.25rem;padding-right:1.25rem}.px-6{padding-left:1.5rem;padding-right:1.5rem}.px-8{padding-left:2rem;padding-right:2rem}.py-2{padding-top:0.5rem;padding-bottom:0.5rem}.py-3{padding-top:0.75rem;padding-bottom:0.75rem}.py-4{padding-top:1rem;padding-bottom:1rem}.py-6{padding-top:1.5rem;padding-bottom:1.5rem}.text-right{text-align:right}.font-mono{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace}.text-2xl{font-size:1.5rem;line-height:2rem}.text-\[24px\]{font-size:24px}.text-\[28px\]{font-size:28px}.text-base{font-size:1rem;line-height:1.5rem}.text-lg{font-size:1.125rem;line-height:1.75rem}.text-sm{font-size:0.875rem;line-height:1.25rem}.text-xl{font-size:1.25rem;line-height:1.75rem}.font-bold{font-weight:700}.font-medium{font-weight:500}.uppercase{text-transform:uppercase}.tracking-wider{letter-spacing:0.05em}.text-slate-400{--tw-text-opacity:1;color:rgb(148 163 184 / var(--tw-text-opacity, 1))}.text-slate-500{--tw-text-opacity:1;color:rgb(100 116 139 / var(--tw-text-opacity, 1))}.text-slate-600{--tw-text-opacity:1;color:rgb(71 85 105 / var(--tw-text-opacity, 1))}.text-slate-700{--tw-text-opacity:1;color:rgb(51 65 85 / var(--tw-text-opacity, 1))}.text-slate-800{--tw-text-opacity:1;color:rgb(30 41 59 / var(--tw-text-opacity, 1))}.text-white{--tw-text-opacity:1;color:rgb(255 255 255 / var(--tw-text-opacity, 1))}.opacity-0{opacity:0}.shadow-2xl{--tw-shadow:0 25px 50px -12px rgb(0 0 0 / 0.25);--tw-shadow-colored:0 25px 50px -12px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}.backdrop-blur-md{--tw-backdrop-blur:blur(12px);-webkit-backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia)}.backdrop-blur-sm{--tw-backdrop-blur:blur(4px);-webkit-backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia)}.transition-all{transition-property:all;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms}.transition-colors{transition-property:color, background-color, border-color, fill, stroke, -webkit-text-decoration-color;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, -webkit-text-decoration-color;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms}.duration-300{transition-duration:300ms}.hover\:bg-red-600:hover{--tw-bg-opacity:1;background-color:rgb(220 38 38 / var(--tw-bg-opacity, 1))}.hover\:bg-slate-100:hover{--tw-bg-opacity:1;background-color:rgb(241 245 249 / var(--tw-bg-opacity, 1))}.hover\:bg-slate-200:hover{--tw-bg-opacity:1;background-color:rgb(226 232 240 / var(--tw-bg-opacity, 1))}.dark\:border-zinc-700:is(.dark *){--tw-border-opacity:1;border-color:rgb(63 63 70 / var(--tw-border-opacity, 1))}.dark\:border-zinc-800:is(.dark *){--tw-border-opacity:1;border-color:rgb(39 39 42 / var(--tw-border-opacity, 1))}.dark\:bg-black:is(.dark *){--tw-bg-opacity:1;background-color:rgb(0 0 0 / var(--tw-bg-opacity, 1))}.dark\:bg-canvas-dark:is(.dark *){--tw-bg-opacity:1;background-color:rgb(9 9 11 / var(--tw-bg-opacity, 1))}.dark\:bg-zinc-800:is(.dark *){--tw-bg-opacity:1;background-color:rgb(39 39 42 / var(--tw-bg-opacity, 1))}.dark\:bg-zinc-900:is(.dark *){--tw-bg-opacity:1;background-color:rgb(24 24 27 / var(--tw-bg-opacity, 1))}.dark\:bg-zinc-900\/95:is(.dark *){background-color:rgb(24 24 27 / 0.95)}.dark\:text-slate-100:is(.dark *){--tw-text-opacity:1;color:rgb(241 245 249 / var(--tw-text-opacity, 1))}.dark\:text-slate-200:is(.dark *){--tw-text-opacity:1;color:rgb(226 232 240 / var(--tw-text-opacity, 1))}.dark\:text-slate-300:is(.dark *){--tw-text-opacity:1;color:rgb(203 213 225 / var(--tw-text-opacity, 1))}.dark\:text-slate-400:is(.dark *){--tw-text-opacity:1;color:rgb(148 163 184 / var(--tw-text-opacity, 1))}.dark\:hover\:bg-zinc-700:hover:is(.dark *){--tw-bg-opacity:1;background-color:rgb(63 63 70 / var(--tw-bg-opacity, 1))}.dark\:hover\:bg-zinc-800:hover:is(.dark *){--tw-bg-opacity:1;background-color:rgb(39 39 42 / var(--tw-bg-opacity, 1))}</style></head>
<body class="h-screen w-screen overflow-hidden bg-canvas-light dark:bg-canvas-dark text-slate-800 dark:text-slate-200 transition-colors duration-300 details-on-hover">
<!-- Main Control Bar -->
<div class="fixed bottom-6 left-1/2 -translate-x-1/2 z-[100] flex items-center gap-2 bg-white/95 dark:bg-zinc-900/95 backdrop-blur-md p-1.5 rounded-2xl shadow-2xl border border-slate-200 dark:border-zinc-800 scale-90 origin-bottom">
<!-- Logo & Menu -->
<div class="relative pl-2 pr-2 group">
    <div class="flex items-center gap-2 cursor-pointer" id="canvas-menu-trigger">
        <svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" class="fill-current text-[#AAC1F0] dark:text-cyan-900/60"><path d="M240-160q-33 0-56.5-23.5T160-240q0-33 23.5-56.5T240-320q33 0 56.5 23.5T320-240q0 33-23.5 56.5T240-160Zm0-240q-33 0-56.5-23.5T160-480q0-33 23.5-56.5T240-560q33 0 56.5 23.5T320-480q0 33-23.5 56.5T240-400Zm0-240q-33 0-56.5-23.5T160-720q0-33 23.5-56.5T240-800q33 0 56.5 23.5T320-720q0 33-23.5 56.5T240-640Zm240 0q-33 0-56.5-23.5T400-720q0-33 23.5-56.5T480-800q33 0 56.5 23.5T560-720q0 33-23.5 56.5T480-640Zm240 0q-33 0-56.5-23.5T640-720q0-33 23.5-56.5T720-800q33 0 56.5 23.5T800-720q0 33-23.5 56.5T720-640ZM480-400q-33 0-56.5-23.5T400-480q0-33 23.5-56.5T480-560q33 0 56.5 23.5T560-480q0 33-23.5 56.5T480-400Zm40 240v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q8 9 12.5 20t4.5 22q0 11-4 22.5T863-380L643-160H520Zm300-263-37-37 37 37ZM580-220h38l121-122-18-19-19-18-122 121v38Zm141-141-19-18 37 37-18-19Z"/></svg>
        <div class="flex items-center gap-0.5">
            <input id="canvas-title" class="font-bold text-sm bg-transparent border-none outline-none w-20 truncate cursor-text text-slate-700 dark:text-slate-200" value="Canvases" readonly spellcheck="false">
            <span class="material-symbols-outlined text-slate-400 text-[20px] opacity-0 transition-opacity" id="canvas-chevron">expand_less</span>
        </div>
    </div>
    <!-- Dropdown -->
    <div class="absolute bottom-full left-0 mb-4 w-56 bg-white dark:bg-zinc-900 rounded-xl shadow-2xl border border-slate-200 dark:border-zinc-800 hidden flex-col overflow-hidden py-1 z-[150]" id="canvas-dropdown">
        <!-- Items Injected Here -->
    </div>
</div>

<div class="h-6 w-px bg-slate-200 dark:bg-zinc-800 mx-0.5"></div>
<button class="p-2 rounded-lg hover:bg-slate-100 dark:hover:bg-zinc-800 transition-colors" id="btn-theme" title="Toggle Theme"><span class="material-symbols-outlined text-[20px]">dark_mode</span></button>
<div class="h-6 w-px bg-slate-200 dark:bg-zinc-800 mx-0.5"></div>
<!-- View Toggle -->
<button class="p-2 rounded-lg hover:bg-slate-100 dark:hover:bg-zinc-800 transition-colors flex items-center gap-2" id="btn-view-toggle">
<span class="material-symbols-outlined text-slate-500 text-[20px]" id="icon-view-toggle">visibility_off</span>
<span class="text-xs font-bold" id="text-view-toggle">Hover</span>
</button>
<div class="h-6 w-px bg-slate-200 dark:bg-zinc-800 mx-0.5"></div>
<!-- Dots Toggle -->
<button class="p-2 rounded-lg hover:bg-slate-100 dark:hover:bg-zinc-800 transition-colors" id="btn-dots-toggle" title="Toggle Dots">
<span class="material-symbols-outlined text-slate-500 text-[20px]" id="icon-dots-toggle">grid_on</span>
</button>
<div class="h-6 w-px bg-slate-200 dark:bg-zinc-800 mx-0.5"></div>
<!-- Label Button -->
<button class="px-3 py-2 rounded-lg bg-slate-100 dark:bg-zinc-800 hover:bg-slate-200 dark:hover:bg-zinc-700 transition-colors flex items-center gap-2 text-xs font-bold" id="btn-add-label">
<span class="material-symbols-outlined text-[20px]">label</span>
<span>Label</span>
</button>
<div class="h-6 w-px bg-slate-200 dark:bg-zinc-800 mx-0.5"></div>
<!-- Scale -->
<div class="flex items-center gap-2 px-2">
<span class="text-[10px] font-bold text-slate-400 uppercase tracking-wider">Scale</span>
<input class="w-24 accent-slate-600" id="global-scale-slider" max="2.0" min="0.2" step="0.1" type="range" value="1.0">
<span class="font-mono text-xs font-bold w-8 text-right" id="global-scale-val">1.0x</span>
</div>
<div class="h-6 w-px bg-slate-200 dark:bg-zinc-800 mx-0.5"></div>

<!-- Actions -->
<button class="p-2 rounded-lg hover:bg-slate-100 dark:hover:bg-zinc-800 transition-colors relative" id="btn-save-canvas" title="Save Canvas">
    <span class="material-symbols-outlined text-[20px]">save</span>
    <span class="absolute top-1.5 right-1.5 w-2 h-2 bg-red-500 rounded-full opacity-0 transition-opacity" id="unsaved-dot"></span>
</button>

<div class="h-6 w-px bg-slate-200 dark:bg-zinc-800 mx-0.5"></div>
<button class="p-2 rounded-lg hover:bg-slate-100 dark:hover:bg-zinc-800 transition-colors" id="btn-copy-all" title="Copy All JSON">
<span class="material-symbols-outlined text-[20px]">data_object</span>
</button>
<button class="p-2 rounded-lg hover:bg-slate-100 dark:hover:bg-zinc-800 transition-colors" id="btn-paste-all" title="Paste JSON">
<span class="material-symbols-outlined text-[20px]">file_download</span>
</button>
<div class="h-6 w-px bg-slate-200 dark:bg-zinc-800 mx-0.5"></div>
<button class="p-2 rounded-lg hover:bg-slate-100 dark:hover:bg-zinc-800 transition-colors" id="btn-undo" title="Undo (Ctrl+Z)">
<span class="material-symbols-outlined text-[20px]">undo</span>
</button>
</div>
<!-- Zoom Controls -->
<div class="fixed bottom-6 right-6 z-50 flex items-center gap-2">
<button class="w-8 h-8 rounded-full hover:bg-slate-200/50 dark:hover:bg-zinc-800/50 transition-colors flex items-center justify-center text-slate-500 dark:text-slate-400" id="btn-zoom-out"><span class="material-symbols-outlined text-[20px]">remove</span></button>
<button class="text-xs font-mono font-bold text-slate-400 dark:text-slate-500 w-10 text-center select-none" id="btn-zoom-reset">60%</button>
<button class="w-8 h-8 rounded-full hover:bg-slate-200/50 dark:hover:bg-zinc-800/50 transition-colors flex items-center justify-center text-slate-500 dark:text-slate-400" id="btn-zoom-in"><span class="material-symbols-outlined text-[20px]">add</span></button>
</div>
<!-- Toast -->
<div class="fixed bottom-32 left-1/2 -translate-x-1/2 z-[60] bg-slate-800 text-white px-6 py-4 rounded-full shadow-2xl text-lg font-medium opacity-0 pointer-events-none transition-all duration-300 transform translate-y-4" id="toast">Notification</div>
<!-- Canvas -->
<div class="w-full h-full relative overflow-hidden dot-bg grabbing outline-none" id="canvas-container" style="background-position: 773.222px 610.222px; background-size: 14.4px 14.4px;" tabindex="-1">
<div class="absolute top-0 left-0 w-full h-full origin-top-left" id="canvas-plane" style="transform: translate(773.222px, 610.222px) scale(0.6);">
<!-- Nodes -->
</div>
</div>
<!-- Confirm Modal -->
<div class="fixed inset-0 z-[200] bg-black/50 hidden backdrop-blur-sm flex items-center justify-center p-4" id="confirm-modal">
<div class="bg-white dark:bg-zinc-900 rounded-2xl shadow-2xl p-6 border border-slate-200 dark:border-zinc-700 max-w-sm w-full transform transition-all scale-100">
<h3 class="text-xl font-bold text-slate-800 dark:text-slate-100 mb-2">Delete Item?</h3>
<p class="text-slate-500 dark:text-slate-400 mb-6">Are you sure you want to remove this item from the canvas?</p>
<div class="flex justify-end gap-3">
<button class="px-4 py-2 rounded-lg font-medium text-slate-600 hover:bg-slate-100 dark:text-slate-300 dark:hover:bg-zinc-800 transition-colors" id="btn-confirm-cancel">Cancel</button>
<button class="px-4 py-2 rounded-lg font-bold bg-red-500 text-white hover:bg-red-600 transition-colors" id="btn-confirm-yes">Delete</button>
</div>
</div>
</div>
<!-- Fullscreen Modal -->
<div class="fixed inset-0 z-[100] bg-black/80 hidden backdrop-blur-sm flex items-center justify-center p-8" id="modal-overlay">
<div class="bg-white dark:bg-zinc-900 w-full h-full shadow-2xl flex overflow-hidden transition-all relative rounded-[10px]" id="modal-content">
<button class="absolute top-4 right-4 z-[110] p-2 rounded-full bg-slate-200/80 hover:bg-slate-300 dark:bg-zinc-800/80 dark:hover:bg-zinc-700 transition-colors backdrop-blur-md text-slate-600 dark:text-slate-300" id="btn-modal-close">
<span class="material-symbols-outlined text-[20px]">close</span>
</button>
<div class="w-2/3 h-full relative bg-slate-100 dark:bg-black border-r border-slate-200 dark:border-zinc-800">
<iframe class="w-full h-full border-0" id="modal-iframe"></iframe>
</div>
<div class="w-1/3 h-full flex flex-col bg-white dark:bg-zinc-900 relative group">
<button class="absolute top-4 left-4 z-20 p-2 rounded-lg bg-slate-100/50 hover:bg-slate-200/80 dark:bg-zinc-800/50 dark:hover:bg-zinc-700/80 transition-colors backdrop-blur-sm text-slate-500 hover:text-slate-700 dark:text-slate-400 dark:hover:text-slate-200 border border-slate-200/50 dark:border-zinc-700/50" id="btn-modal-copy-top" title="Copy Full HTML">
<span class="material-symbols-outlined text-[16px]">content_copy</span>
</button>
<div id="monaco-container" class="flex-1 w-full h-full"></div>
<button class="absolute bottom-6 right-6 p-3 rounded-xl bg-slate-100 hover:bg-slate-200 dark:bg-zinc-800 dark:hover:bg-zinc-700 transition-all shadow-lg text-slate-600 dark:text-slate-400 opacity-0 group-hover:opacity-100 translate-y-2 group-hover:translate-y-0" id="btn-modal-copy" title="Copy Code">
<span class="material-symbols-outlined text-[20px]">content_copy</span>
</button>
</div>
</div>
</div>
<script>
    const App = {
        state: {
            zoom: 0.6,
            pan: { x: 0, y: 0 },
            nodes: [],
            
            // Multi-Canvas State
            canvases: [], 
            activeCanvasId: null,
            isDirty: false,

            history: [],
            historyIndex: -1,
            globalContentScale: 1.0,
            versionCounter: 0,
            theme: 'light',
            viewMode: 'hover',
            
            isCanvasDragging: false,
            isNodeDragging: false,
            isResizing: false,
            isScrubbing: false,
            isSpacePressed: false,
            activeNodeId: null,
            lastMouse: { x: 0, y: 0 },
            scrubStart: { x: 0, value: 0 },
            scrubTarget: null,
            
            pendingDeleteId: null,
            pendingCanvasDeleteId: null,
            preDragState: null
        },

        editor: null, // Monaco instance

        els: {
            container: document.getElementById('canvas-container'),
            plane: document.getElementById('canvas-plane'),
            toast: document.getElementById('toast'),
            modal: document.getElementById('modal-overlay'),
            modalIframe: document.getElementById('modal-iframe'),
            confirmModal: document.getElementById('confirm-modal'),
            
            // Canvas Menu
            canvasTitle: document.getElementById('canvas-title'),
            canvasChevron: document.getElementById('canvas-chevron'),
            canvasDropdown: document.getElementById('canvas-dropdown'),
            unsavedDot: document.getElementById('unsaved-dot')
        },

        init() {
            this.loadTheme();
            this.initMonaco();
            this.loadStorage(); // Load Canvases
            this.setupCanvasEvents();
            this.setupUIEvents();
            this.centerView();
            this.renderTransform(); 
            this.recordState(); // Initial State
            
            window.addEventListener('keydown', e => this.handleKeydown(e));
            window.addEventListener('keyup', e => this.handleKeyup(e));
            window.addEventListener('paste', e => this.handlePaste(e), true);
            
            // Unsaved changes warning
            window.onbeforeunload = (e) => {
                if (this.state.isDirty) {
                    e.preventDefault();
                    e.returnValue = '';
                }
            };
        },

        // --- Storage & Multi-Canvas ---

        loadStorage() {
            try {
                const data = localStorage.getItem('htmlcanvases_data');
                if (data) {
                    const parsed = JSON.parse(data);
                    this.state.canvases = parsed.canvases || [];
                    
                    // If we have an active ID saved, try to load it
                    if (parsed.activeId && this.state.canvases.find(c => c.id === parsed.activeId)) {
                        this.switchCanvas(parsed.activeId, false);
                    } else if (this.state.canvases.length > 0) {
                        this.switchCanvas(this.state.canvases[0].id, false);
                    } else {
                        // No canvases, start fresh (scratchpad mode)
                        this.state.activeCanvasId = null;
                        this.updateCanvasUI();
                    }
                } else {
                    this.updateCanvasUI();
                }
            } catch (e) {
                console.error("Failed to load storage", e);
                this.updateCanvasUI();
            }
        },

        saveStorage() {
            const data = {
                canvases: this.state.canvases,
                activeId: this.state.activeCanvasId
            };
            localStorage.setItem('htmlcanvases_data', JSON.stringify(data));
        },

        saveCurrentCanvas() {
            // If scratchpad (null ID), create new
            if (!this.state.activeCanvasId) {
                this.createCanvas(true); // Create and save
                return;
            }

            // Update existing
            const canvas = this.state.canvases.find(c => c.id === this.state.activeCanvasId);
            if (canvas) {
                canvas.nodes = this.state.nodes;
                canvas.lastModified = Date.now();
                // Name is updated via input binding immediately
                this.saveStorage();
                this.setDirty(false);
                this.showToast('Canvas Saved');
                this.updateCanvasUI();
            }
        },

        createCanvas(saveCurrentAsNew = false) {
            // If we are just clicking "New", we might want to warn if current is dirty
            // For now, let's assume "New" creates a fresh empty canvas
            
            if (saveCurrentAsNew) {
                // Converting scratchpad to saved canvas
                const newId = crypto.randomUUID();
                const newCanvas = {
                    id: newId,
                    name: 'Canvas ' + (this.state.canvases.length + 1),
                    nodes: this.state.nodes, // Current nodes
                    lastModified: Date.now()
                };
                this.state.canvases.push(newCanvas);
                this.state.activeCanvasId = newId;
                this.saveStorage();
                this.setDirty(false);
                this.updateCanvasUI();
                this.showToast('Canvas Created');
            } else {
                // "Plus" button - Clean slate
                // If dirty, maybe we should auto-save current if it exists?
                if (this.state.activeCanvasId && this.state.isDirty) {
                    this.saveCurrentCanvas();
                }
                
                const newId = crypto.randomUUID();
                const newCanvas = {
                    id: newId,
                    name: 'Canvas ' + (this.state.canvases.length + 1),
                    nodes: [],
                    lastModified: Date.now()
                };
                this.state.canvases.push(newCanvas);
                this.switchCanvas(newId, false);
                this.saveStorage();
                this.showToast('New Canvas Created');
            }
        },

        switchCanvas(id, saveCurrent = true) {
            // Save current if needed before switching
            if (saveCurrent && this.state.activeCanvasId && this.state.isDirty) {
                // Auto-save logic or just let it persist in memory? 
                // Let's update the in-memory object at least
                const current = this.state.canvases.find(c => c.id === this.state.activeCanvasId);
                if(current) current.nodes = this.state.nodes;
            }

            const target = this.state.canvases.find(c => c.id === id);
            if (target) {
                this.state.activeCanvasId = id;
                this.state.nodes = JSON.parse(JSON.stringify(target.nodes)); // Deep copy to avoid ref issues
                this.restoreState(this.state.nodes);
                this.state.history = []; // Reset history for new canvas
                this.state.historyIndex = -1;
                this.recordState();
                this.setDirty(false);
                this.updateCanvasUI();
            }
        },

        deleteCanvas(id) {
            this.state.pendingCanvasDeleteId = id;
            // Re-use confirm modal but change text temporarily
            const title = this.els.confirmModal.querySelector('h3');
            const body = this.els.confirmModal.querySelector('p');
            
            title.innerText = "Delete Canvas?";
            body.innerText = "This will permanently delete this canvas and all its contents.";
            
            this.els.confirmModal.classList.remove('hidden');
        },

        renameCanvas(newName) {
            if (!this.state.activeCanvasId) return; // Can't rename scratchpad effectively until saved
            const canvas = this.state.canvases.find(c => c.id === this.state.activeCanvasId);
            if (canvas) {
                canvas.name = newName;
                this.saveStorage(); // Auto-persist name changes
            }
        },

        setDirty(isDirty) {
            this.state.isDirty = isDirty;
            this.els.unsavedDot.style.opacity = isDirty ? '1' : '0';
        },

        updateCanvasUI() {
            // 1. Title
            if (this.state.activeCanvasId) {
                const c = this.state.canvases.find(i => i.id === this.state.activeCanvasId);
                this.els.canvasTitle.value = c ? c.name : 'Canvases';
                this.els.canvasTitle.readOnly = false;
                this.els.canvasTitle.classList.add('pointer-events-auto');
                this.els.canvasTitle.classList.remove('pointer-events-none');
            } else {
                this.els.canvasTitle.value = 'Canvases';
                // Allow editing 'Canvases' title which effectively creates a new canvas upon save/rename?
                // For now, let's keep the previous logic: Rename only active.
                // But user asked "allow me at any time to rename... by clicking".
                // If it's the scratchpad, maybe we should auto-create on rename?
                // Let's stick to: Rename works if active. If scratchpad, it remains "Canvases" until saved.
                this.els.canvasTitle.readOnly = true;
                this.els.canvasTitle.classList.remove('pointer-events-auto');
                this.els.canvasTitle.classList.add('pointer-events-none');
            }

            // 2. Chevron - Always visible now
            this.els.canvasChevron.style.opacity = '1';
            document.getElementById('canvas-menu-trigger').classList.add('cursor-pointer');

            // 3. Render Dropdown
            this.els.canvasDropdown.innerHTML = '';
            
            // A. New Canvas Option
            const newItem = document.createElement('div');
            newItem.className = 'px-4 py-3 hover:bg-slate-100 dark:hover:bg-zinc-800 cursor-pointer flex items-center gap-3 text-blue-600 dark:text-blue-400 font-bold border-b border-slate-100 dark:border-zinc-800 mb-1';
            newItem.innerHTML = '<span class="material-symbols-outlined text-[20px]">add</span><span>New Canvas</span>';
            newItem.onclick = (e) => {
                e.stopPropagation();
                this.createCanvas();
                this.els.canvasDropdown.classList.add('hidden');
            };
            this.els.canvasDropdown.appendChild(newItem);

            // B. Other Canvases
            if (this.state.canvases.length > 0) {
                this.state.canvases.forEach(c => {
                    // Skip current
                    if (c.id === this.state.activeCanvasId) return;

                    const item = document.createElement('div');
                    item.className = 'px-4 py-2 hover:bg-slate-100 dark:hover:bg-zinc-800 cursor-pointer flex justify-between items-center group/item text-slate-700 dark:text-slate-300';
                    
                    const nameSpan = document.createElement('span');
                    nameSpan.className = 'truncate flex-1';
                    nameSpan.innerText = c.name;
                    nameSpan.onclick = () => {
                        this.switchCanvas(c.id);
                        this.els.canvasDropdown.classList.add('hidden');
                    };

                    const delBtn = document.createElement('button');
                    delBtn.className = 'opacity-0 group-hover/item:opacity-100 p-1 hover:bg-red-100 dark:hover:bg-red-900/30 rounded text-red-500 transition-all';
                    delBtn.innerHTML = '<span class="material-symbols-outlined text-[16px]">delete</span>';
                    delBtn.onclick = (e) => {
                        e.stopPropagation();
                        this.deleteCanvas(c.id);
                    };

                    item.append(nameSpan, delBtn);
                    this.els.canvasDropdown.appendChild(item);
                });
            }
        },

        initMonaco() {
            require.config({ paths: { 'vs': 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.45.0/min/vs' }});
            require(['vs/editor/editor.main'], () => {
                this.editor = monaco.editor.create(document.getElementById('monaco-container'), {
                    value: '',
                    language: 'html',
                    theme: this.state.theme === 'dark' ? 'vs-dark' : 'vs',
                    minimap: { enabled: false },
                    fontSize: 12,
                    readOnly: true,
                    automaticLayout: true,
                    scrollBeyondLastLine: false,
                    padding: { top: 20, bottom: 20 }
                });
            });
        },

        // --- History & State ---
        recordState() {
            // Update "Dirty" if this isn't the first load
            if (this.state.historyIndex > -1) {
                this.setDirty(true);
            }

            const stateStr = JSON.stringify(this.state.nodes);
            // If new state is different from current head, push
            if (this.state.historyIndex > -1 && this.state.history[this.state.historyIndex] === stateStr) {
                return;
            }
            // Slice forward history if we are in the middle
            if (this.state.historyIndex < this.state.history.length - 1) {
                this.state.history = this.state.history.slice(0, this.state.historyIndex + 1);
            }
            this.state.history.push(stateStr);
            this.state.historyIndex++;
            // Limit history
            if (this.state.history.length > 50) {
                this.state.history.shift();
                this.state.historyIndex--;
            }
        },

        undo() {
            if (this.state.historyIndex > 0) {
                this.state.historyIndex--;
                const raw = this.state.history[this.state.historyIndex];
                this.restoreState(JSON.parse(raw));
                this.showToast('Undo');
            }
        },

        redo() {
            if (this.state.historyIndex < this.state.history.length - 1) {
                this.state.historyIndex++;
                const raw = this.state.history[this.state.historyIndex];
                this.restoreState(JSON.parse(raw));
                this.showToast('Redo');
            }
        },

        restoreState(nodes) {
            this.state.nodes = nodes;
            this.els.plane.innerHTML = '';
            // Render all
            // Separate labels and snippets
            const labels = nodes.filter(n => n.type === 'label');
            const snippets = nodes.filter(n => n.type !== 'label');
            labels.forEach(n => this.renderLabel(n));
            snippets.forEach(n => this.renderSnippet(n));
            this.updateAllLabelInteractions();
        },

        handleKeydown(e) {
            // Spacebar Panning
            if (e.code === 'Space' && !this.state.isSpacePressed) {
                // Don't trigger if typing in an input
                if (document.activeElement && ['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName)) return;
                
                this.state.isSpacePressed = true;
                this.els.container.style.cursor = 'grab';
                e.preventDefault(); 
            }

            if (e.key === 'Escape') {
                this.closeModal();
                this.closeConfirm();
                this.els.canvasDropdown.classList.add('hidden');
            }
            if ((e.ctrlKey || e.metaKey) && e.key === '0') { e.preventDefault(); this.resetZoom(); }
            // Undo/Redo
            if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') {
                e.preventDefault();
                if (e.shiftKey) this.redo();
                else this.undo();
            }
            if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'y') {
                e.preventDefault();
                this.redo();
            }
        },

        handleKeyup(e) {
            if (e.code === 'Space') {
                this.state.isSpacePressed = false;
                if (!this.state.isCanvasDragging) {
                    this.els.container.style.cursor = '';
                }
            }
        },

        // --- Canvas Interaction ---
        setupCanvasEvents() {
            const c = this.els.container;

            // Global mousedown listener for Space Panning
            window.addEventListener('mousedown', e => {
                if (this.state.isSpacePressed) {
                    e.preventDefault();
                    e.stopPropagation();
                    this.state.isCanvasDragging = true;
                    this.state.lastMouse = { x: e.clientX, y: e.clientY };
                    c.classList.add('grabbing');
                    c.style.cursor = 'grabbing';
                    return; // Stop other interactions
                }
            }, true); // Capture phase to override element interactions

            c.addEventListener('mousedown', e => {
                // Blur active element if clicking on background
                if (document.activeElement && ['INPUT', 'TEXTAREA', 'IFRAME'].includes(document.activeElement.tagName)) {
                    document.activeElement.blur();
                }
                
                // Force focus to container to capture global events
                c.focus();

                if (e.target === c || e.target === this.els.plane) {
                    e.preventDefault(); // Prevent default browser selection/focus behavior
                    this.state.isCanvasDragging = true;
                    this.state.lastMouse = { x: e.clientX, y: e.clientY };
                    c.classList.add('grabbing');
                    // Close dropdown if clicking canvas
                    this.els.canvasDropdown.classList.add('hidden');
                }
            });
            // ... (rest of setupCanvasEvents is same, just need to ensure bracket match)


            window.addEventListener('mousemove', e => {
                const dx = e.clientX - this.state.lastMouse.x;
                const dy = e.clientY - this.state.lastMouse.y;
                
                if (this.state.isScrubbing && this.state.scrubTarget) {
                    e.preventDefault();
                    const delta = Math.round((e.clientX - this.state.scrubStart.x) / 2); 
                    const newVal = this.state.scrubStart.value + delta;
                    if (this.state.scrubTarget.callback) {
                        this.state.scrubTarget.callback(newVal);
                    }
                    return; 
                }

                if (this.state.isCanvasDragging) {
                    this.state.pan.x += dx;
                    this.state.pan.y += dy;
                    this.renderTransform();
                }
                else if (this.state.isNodeDragging && this.state.activeNodeId) {
                    const node = this.state.nodes.find(n => n.id === this.state.activeNodeId);
                    if (node) {
                        node.x += dx / this.state.zoom;
                        node.y += dy / this.state.zoom;
                        const el = document.getElementById(`node-${node.id}`);
                        if (el) this.updateNodeGeometry(el, node);
                    }
                }
                else if (this.state.isResizing && this.state.activeNodeId) {
                    const node = this.state.nodes.find(n => n.id === this.state.activeNodeId);
                    if (node) {
                        node.width = Math.max(300, node.width + (dx / this.state.zoom));
                        node.height = Math.max(150, node.height + (dy / this.state.zoom));
                        const el = document.getElementById(`node-${node.id}`);
                        if (el) this.updateNodeGeometry(el, node);
                    }
                }
                this.state.lastMouse = { x: e.clientX, y: e.clientY };
            });

            window.addEventListener('mouseup', () => {
                if (this.state.isNodeDragging || this.state.isResizing) {
                    this.updateAllLabelInteractions();
                    // Check if state changed significantly
                    const currentState = JSON.stringify(this.state.nodes);
                    if (this.state.preDragState !== currentState) {
                        this.recordState();
                    }
                }
                
                this.state.isCanvasDragging = false;
                this.state.isNodeDragging = false;
                this.state.isResizing = false;
                this.state.isScrubbing = false;
                this.state.scrubTarget = null;
                this.state.activeNodeId = null;
                this.state.preDragState = null;
                
                c.classList.remove('grabbing');
                document.body.style.cursor = '';
                document.querySelectorAll('.canvas-node').forEach(n => n.classList.remove('selected'));
            });

            c.addEventListener('wheel', e => {
                e.preventDefault();
                const delta = -e.deltaY * 0.001;
                const newZoom = Math.min(Math.max(0.1, this.state.zoom + delta), 5);
                const rect = c.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                const worldX = (mouseX - this.state.pan.x) / this.state.zoom;
                const worldY = (mouseY - this.state.pan.y) / this.state.zoom;
                this.state.pan.x = mouseX - worldX * newZoom;
                this.state.pan.y = mouseY - worldY * newZoom;
                this.state.zoom = newZoom;
                this.renderTransform();
            }, { passive: false });
        },

        renderTransform() {
            const { x, y } = this.state.pan;
            const z = this.state.zoom;
            this.els.plane.style.transform = `translate(${x}px, ${y}px) scale(${z})`;
            document.getElementById('btn-zoom-reset').innerText = `${Math.round(z * 100)}%`;
            this.els.container.style.backgroundPosition = `${x}px ${y}px`;
            this.els.container.style.backgroundSize = `${24 * z}px ${24 * z}px`;
        },

        centerView() {
            const r = this.els.container.getBoundingClientRect();
            this.state.pan = { x: r.width / 2, y: r.height / 2 };
            this.renderTransform();
        },

        resetZoom() { this.state.zoom = 0.6; this.centerView(); },

        // --- Logic Helpers ---

        isNumeric(val) { return /^-?\d*\.?\d+(px|rem|em|%|vh|vw|)$/i.test(val.trim()); },
        parseNumeric(val) {
            const match = val.match(/^(-?\d*\.?\d+)(.*)$/);
            if (match) return { num: parseFloat(match[1]), unit: match[2] };
            return null;
        },

        getContrastYIQ(hexcolor) {
            hexcolor = hexcolor.replace("#", "");
            if (hexcolor.length === 3) hexcolor = hexcolor.split('').map(c => c+c).join('');
            var r = parseInt(hexcolor.substr(0,2),16);
            var g = parseInt(hexcolor.substr(2,2),16);
            var b = parseInt(hexcolor.substr(4,2),16);
            var yiq = ((r*299)+(g*587)+(b*114))/1000;
            return (yiq >= 128) ? '#000000' : '#ffffff';
        },

        updateAllLabelInteractions() {
            const labels = this.state.nodes.filter(n => n.type === 'label');
            const snippets = this.state.nodes.filter(n => n.type === 'snippet');
            snippets.forEach(snip => {
                const el = document.getElementById(`node-${snip.id}`);
                if (!el) return;
                let color = ''; 
                const cx = snip.x + snip.width / 2;
                const cy = snip.y + snip.height / 2;
                for (let i = labels.length - 1; i >= 0; i--) {
                    const lbl = labels[i];
                    if (cx >= lbl.x && cx <= lbl.x + lbl.width && cy >= lbl.y && cy <= lbl.y + lbl.height) {
                        color = lbl.color;
                        break; 
                    }
                }
                if (color) el.style.setProperty('--title-color', color);
                else el.style.removeProperty('--title-color');
            });
        },

        updateLabelDependents(labelNode) {
            const labelEl = document.getElementById(`node-${labelNode.id}`);
            if (labelEl) {
                labelEl.style.backgroundColor = labelNode.color + '25'; 
                labelEl.style.borderColor = labelNode.color;
                const ta = labelEl.querySelector('textarea');
                if (ta) ta.style.color = labelNode.color;
                
                const titleInput = labelEl.querySelector('.label-title');
                if (titleInput) titleInput.style.color = labelNode.color;
            }
            this.updateAllLabelInteractions();
        },

        // --- Creation ---

        findClearSpot(width, height) {
            const r = this.els.container.getBoundingClientRect();
            let startX = (r.width/2 - this.state.pan.x) / this.state.zoom - width/2;
            let startY = (r.height/2 - this.state.pan.y) / this.state.zoom - height/2;
            if (this.state.nodes.length === 0) return { x: startX, y: startY };
            let angle = 0; let radius = 0; let maxAttempts = 200;
            for(let i=0; i<maxAttempts; i++) {
                const x = startX + radius * Math.cos(angle);
                const y = startY + radius * Math.sin(angle);
                let collision = false;
                for (const node of this.state.nodes) {
                    if (x < node.x + node.width + 50 && x + width + 50 > node.x && y < node.y + node.height + 50 && y + height + 50 > node.y) {
                        collision = true; break;
                    }
                }
                if(!collision) return { x, y };
                angle += 1; radius += 10;
            }
            return { x: startX + 50, y: startY + 50 };
        },

        handlePaste(e) {
            const target = e.target;
            // Allow normal paste if we are in a writable input/textarea or contentEditable element
            if (['INPUT', 'TEXTAREA'].includes(target.tagName)) {
                if (!target.readOnly && !target.disabled) return;
            }
            if (target.isContentEditable) return;

            // Otherwise, capture it for the app
            e.preventDefault();
            e.stopPropagation();

            const content = (e.clipboardData || window.clipboardData).getData('Text');
            if (!content || !content.trim()) return;

            // Try JSON
            try {
                const data = JSON.parse(content);
                if (data.nodes && Array.isArray(data.nodes) && data.version) {
                    this.loadCanvasState(data);
                    this.recordState(); // Record paste action
                    return; 
                }
            } catch (err) {}

            // Try URL
            const urlRegex = /^(http|https):\/\/[^ "]+$/;
            if (urlRegex.test(content.trim())) {
                const url = content.trim();
                const iframeHtml = `<iframe src="${url}" style="width:100%; height:100%; border:none; display:block;"></iframe>`;
                try {
                    this.createSnippetNode(iframeHtml);
                    return;
                } catch (err) {
                    console.error("Paste URL error:", err);
                }
            }

            // Fallback HTML
            try {
                this.createSnippetNode(content);
            } catch (err) {
                console.error("Paste error:", err);
                this.showToast('Error pasting content');
            }
        },

        loadCanvasState(data) {
            this.els.plane.innerHTML = '';
            this.state.nodes = [];
            this.state.versionCounter = 0;
            const labels = data.nodes.filter(n => n.type === 'label');
            const snippets = data.nodes.filter(n => n.type !== 'label');
            labels.forEach(n => { this.state.nodes.push(n); this.renderLabel(n); });
            snippets.forEach(n => {
                if(!n.type) n.type = 'snippet';
                this.state.nodes.push(n);
                this.renderSnippet(n);
                const v = parseInt(n.version.replace('v1.','') || 0);
                if(v > this.state.versionCounter) this.state.versionCounter = v;
            });
            this.showToast('Canvas Configuration Loaded');
            this.updateAllLabelInteractions();
        },

        createSnippetNode(content, config = null) {
            const width = config ? config.width : 900;
            const height = config ? config.height : 600;
            let x, y;
            if(config){ x=config.x; y=config.y; }
            else { 
               const pos = this.findClearSpot(width, height);
               x = pos.x; y = pos.y;
            }

            if (!config) this.state.versionCounter++;
            const version = config ? config.version : `v1.${this.state.versionCounter}`;

            const node = {
                id: config ? config.id : crypto.randomUUID(),
                type: 'snippet',
                version, content,
                prompt: config ? config.prompt : '',
                cssVars: config ? config.cssVars : this.parseCssVars(content),
                x, y, width, height
            };

            this.state.nodes.push(node);
            this.renderSnippet(node);
            this.updateAllLabelInteractions();
            this.recordState();
            if (!config) this.showToast(`Added ${version}`);
        },

        createLabelNode(config = null) {
            const width = config ? config.width : 600;
            const height = config ? config.height : 400;
            let x, y;
            if(config){x=config.x;y=config.y;}
            else {
                const pos = this.findClearSpot(width, height);
                x = pos.x; y = pos.y;
            }

            const node = {
                id: config ? config.id : crypto.randomUUID(),
                type: 'label',
                text: config ? config.text : 'Label',
                color: config ? config.color : '#3b82f6',
                x, y, width, height
            };
            this.state.nodes.unshift(node);
            this.renderLabel(node);
            this.recordState();
        },

        deleteNode(id) {
            this.state.pendingDeleteId = id;
            this.els.confirmModal.classList.remove('hidden');
        },

        confirmDelete() {
            // Handle Item Delete
            if (this.state.pendingDeleteId) {
                const idx = this.state.nodes.findIndex(n => n.id === this.state.pendingDeleteId);
                if (idx > -1) {
                    this.state.nodes.splice(idx, 1);
                    document.getElementById(`node-${this.state.pendingDeleteId}`).remove();
                    this.updateAllLabelInteractions();
                    this.recordState();
                }
                this.state.pendingDeleteId = null;
            }
            
            // Handle Canvas Delete
            if (this.state.pendingCanvasDeleteId) {
                const id = this.state.pendingCanvasDeleteId;
                const idx = this.state.canvases.findIndex(c => c.id === id);
                if (idx > -1) {
                    this.state.canvases.splice(idx, 1);
                    // If deleted current
                    if (id === this.state.activeCanvasId) {
                        if (this.state.canvases.length > 0) {
                            this.switchCanvas(this.state.canvases[0].id, false);
                        } else {
                            // Back to scratchpad
                            this.state.activeCanvasId = null;
                            this.state.nodes = [];
                            this.els.plane.innerHTML = '';
                            this.setDirty(false);
                            this.updateCanvasUI();
                        }
                    } else {
                        // Just save list
                        this.saveStorage();
                        this.updateCanvasUI();
                    }
                    this.showToast('Canvas Deleted');
                }
                this.state.pendingCanvasDeleteId = null;
            }
            
            this.closeConfirm();
        },

        closeConfirm() {
            this.state.pendingDeleteId = null;
            this.state.pendingCanvasDeleteId = null;
            this.els.confirmModal.classList.add('hidden');
            
            // Reset text
            const title = this.els.confirmModal.querySelector('h3');
            const body = this.els.confirmModal.querySelector('p');
            title.innerText = "Delete Item?";
            body.innerText = "Are you sure you want to remove this item from the canvas?";
        },

        // --- Rendering ---

        renderSnippet(node) {
            const el = document.createElement('div');
            el.id = `node-${node.id}`;
            el.className = 'canvas-node type-snippet';
            
            const header = document.createElement('div');
            header.className = 'node-header';
            header.innerHTML = `
                <input class="node-title select-none bg-transparent border-none outline-none w-48 truncate" value="${node.version}" spellcheck="false">
                <div class="node-actions">
                    <button class="action-btn" id="btn-settings-${node.id}" title="Settings"><span class="material-symbols-outlined">settings</span></button>
                    <button class="action-btn node-copy" title="Copy Code"><span class="material-symbols-outlined">content_copy</span></button>
                    <button class="action-btn node-full" title="Fullscreen"><span class="material-symbols-outlined">fullscreen</span></button>
                    <button class="action-btn delete node-del" title="Delete"><span class="material-symbols-outlined">delete</span></button>
                </div>
            `;
            const titleInput = header.querySelector('.node-title');
            titleInput.addEventListener('mousedown', e => { e.stopPropagation(); }); // Allow focus
            titleInput.oninput = e => { node.version = e.target.value; };
            titleInput.onchange = () => this.recordState();
            
            // Allow dragging from the area around the input if needed, or rely on other areas
            // header.addEventListener('mousedown', e => { if(e.target !== titleInput) this.startDrag(e, node.id); }); 
            // Better: make a drag handle or just rely on the fact that the header is big
            
            // Re-bind drag to the header itself but exclude the input interaction
            header.addEventListener('mousedown', e => {
                if (e.target !== titleInput && !e.target.closest('.node-actions')) {
                    this.startDrag(e, node.id);
                }
            });

            header.querySelector('.node-del').onclick = e => { e.stopPropagation(); this.deleteNode(node.id); };
            header.querySelector('.node-full').onclick = e => { e.stopPropagation(); this.openModal(node); };
            header.querySelector('.node-copy').onclick = e => { e.stopPropagation(); this.copyNodeCode(node); };
            
            header.querySelector(`#btn-settings-${node.id}`).onclick = e => {
                e.stopPropagation();
                el.classList.toggle('vars-expanded');
            };

            const wrapper = document.createElement('div');
            wrapper.className = 'node-preview-wrapper';
            const resizer = document.createElement('div');
            resizer.className = 'node-resizer';
            resizer.onmousedown = e => this.startResize(e, node.id);

            const preview = document.createElement('div');
            preview.className = 'relative w-full h-full bg-white dark:bg-black';
            const scaleWrap = document.createElement('div');
            scaleWrap.className = 'iframe-scaler';
            const iframe = document.createElement('iframe');
            iframe.className = 'w-full h-full border-0 pointer-events-none';
            iframe.sandbox = 'allow-scripts allow-same-origin';
            
            const overlay = document.createElement('div');
            overlay.className = 'absolute inset-0 z-10';
            overlay.addEventListener('mousedown', e => this.startDrag(e, node.id));

            scaleWrap.appendChild(iframe);
            preview.appendChild(scaleWrap);
            preview.appendChild(overlay);
            wrapper.appendChild(preview);
            wrapper.appendChild(resizer);
            
            // Double click to fullscreen
            wrapper.addEventListener('dblclick', (e) => {
                e.stopPropagation();
                this.openModal(node);
            });

            const extras = document.createElement('div');
            extras.className = 'node-extras';

            const varsSec = document.createElement('div');
            varsSec.className = 'node-vars';
            const hasVars = Object.keys(node.cssVars).length > 0;
            if (hasVars) {
                varsSec.innerHTML = `<div class="grid grid-cols-2 gap-3 vars-grid"></div>`;
                const grid = varsSec.querySelector('.vars-grid');
                Object.entries(node.cssVars).forEach(([key, val]) => {
                    const cell = document.createElement('div');
                    cell.className = 'flex items-center gap-2 bg-slate-100 dark:bg-zinc-800/50 rounded-xl p-3 min-w-0 border border-slate-200 dark:border-zinc-700/50';
                    const lbl = document.createElement('span');
                    lbl.className = 'var-label font-mono text-slate-500 truncate w-24 shrink-0 font-bold';
                    lbl.innerText = key.replace('--','');
                    const isColor = /^(#|rgb|hsl)/i.test(val.trim());
                    if (isColor) {
                         const wrap = document.createElement('div');
                         wrap.className = 'flex items-center gap-2 flex-1 min-w-0';
                         const cp = document.createElement('input'); 
                         cp.type = 'color';
                         cp.className = 'p-0 border-0 rounded cursor-pointer bg-transparent shrink-0';
                         cp.value = val.trim().startsWith('#') ? val.trim() : '#000000'; 
                         const hexTxt = document.createElement('span');
                         hexTxt.className = 'hex-text font-mono flex-1 truncate select-all font-medium';
                         hexTxt.innerText = val.trim();
                         cp.oninput = e => { 
                             hexTxt.innerText = e.target.value; 
                             node.cssVars[key] = e.target.value; 
                             this.updateIframe(node.id); 
                         };
                         // Record state on change (blur/commit)
                         cp.onchange = () => this.recordState();
                         wrap.append(cp, hexTxt);
                         cell.append(lbl, wrap);
                    } else if (this.isNumeric(val)) {
                        const parsed = this.parseNumeric(val);
                        const inp = document.createElement('span');
                        inp.className = 'scrub-input font-mono flex-1 cursor-ew-resize select-none px-1 truncate font-medium';
                        inp.innerText = val;
                        inp.onmousedown = e => {
                            e.stopPropagation();
                            this.state.isScrubbing = true;
                            this.state.scrubStart = { x: e.clientX, value: parsed.num };
                            this.state.scrubTarget = {
                                callback: (newNum) => {
                                    const newVal = newNum + parsed.unit;
                                    inp.innerText = newVal;
                                    node.cssVars[key] = newVal;
                                    this.updateIframe(node.id);
                                }
                            };
                            document.body.style.cursor = 'ew-resize';
                        };
                        cell.append(lbl, inp);
                    } else {
                         const inp = document.createElement('input'); 
                         inp.type = 'text';
                         inp.className = 'min-w-0 flex-1 bg-transparent border-0 font-mono focus:outline-none h-6 text-slate-700 dark:text-slate-300 font-medium';
                         inp.value = val;
                         inp.oninput = e => { node.cssVars[key] = e.target.value; this.updateIframe(node.id); };
                         inp.onchange = () => this.recordState();
                         inp.onmousedown = e => e.stopPropagation();
                         cell.append(lbl, inp);
                    }
                    grid.appendChild(cell);
                });
                extras.appendChild(varsSec);
            }

            const promptSec = document.createElement('div');
            promptSec.className = 'node-prompt';
            promptSec.innerHTML = `<textarea class="w-full bg-slate-50 dark:bg-zinc-800/50 border border-slate-200 dark:border-zinc-700 rounded-lg p-3 font-mono h-24 resize-none focus:outline-none placeholder-slate-400 leading-relaxed text-slate-700 dark:text-slate-300 font-medium" placeholder="Notes...">${node.prompt}</textarea>`;
            const ta = promptSec.querySelector('textarea');
            ta.oninput = e => node.prompt = e.target.value;
            ta.onchange = () => this.recordState();
            ta.onmousedown = e => e.stopPropagation();
            extras.appendChild(promptSec);

            el.append(header, wrapper, extras);
            this.els.plane.appendChild(el);
            this.updateNodeGeometry(el, node);
            this.updateIframe(node.id);
            this.updateNodeGlobalScale(node.id);
        },

        renderLabel(node) {
            const el = document.createElement('div');
            el.id = `node-${node.id}`;
            el.className = 'canvas-node type-label border-4 rounded-3xl flex flex-col group';
            el.style.backgroundColor = node.color + '25'; 
            el.style.borderColor = node.color;
            this.updateNodeGeometry(el, node);

            const header = document.createElement('div');
            header.className = 'label-header';

            header.innerHTML = `
                <input class="label-title" value="${node.text}" style="color: ${node.color}">
                <div class="label-controls">
                    <div class="color-swatch-wrapper">
                        <input type="color" class="color-swatch" value="${node.color}">
                    </div>
                    <button class="action-btn delete label-del" style="padding:10px;"><span class="material-symbols-outlined" style="font-size:28px">delete</span></button>
                </div>
            `;
            
            const titleInput = header.querySelector('.label-title');
            titleInput.oninput = e => node.text = e.target.value;
            titleInput.onchange = () => this.recordState();
            titleInput.onmousedown = e => e.stopPropagation();

            const colorInput = header.querySelector('.color-swatch');
            colorInput.oninput = e => {
                node.color = e.target.value;
                this.updateLabelDependents(node);
            };
            colorInput.onchange = () => this.recordState();
            colorInput.onmousedown = e => e.stopPropagation();

            const delBtn = header.querySelector('.label-del');
            delBtn.onclick = e => { e.stopPropagation(); this.deleteNode(node.id); };
            
            el.addEventListener('mousedown', e => {
                if(e.target === el || e.target === header) this.startDrag(e, node.id);
            });

            const resizer = document.createElement('div');
            resizer.className = 'node-resizer';
            resizer.onmousedown = e => this.startResize(e, node.id);

            el.append(header, resizer);
            this.els.plane.insertBefore(el, this.els.plane.firstChild);
        },

        updateNodeGeometry(el, node) {
            el.style.left = node.x + 'px';
            el.style.top = node.y + 'px';
            if (node.type === 'snippet') {
                const wrapper = el.querySelector('.node-preview-wrapper');
                if(wrapper) {
                    wrapper.style.width = node.width + 'px';
                    wrapper.style.height = node.height + 'px';
                }
            } else {
                el.style.width = node.width + 'px';
                el.style.height = node.height + 'px';
            }
        },

        // --- Basic Ops ---
        startDrag(e, id) {
            e.preventDefault(); e.stopPropagation();
            
            // Force focus to container to capture keyboard events
            this.els.container.focus();

            this.state.preDragState = JSON.stringify(this.state.nodes);
            this.state.isCanvasDragging = false;
            this.state.isNodeDragging = true;
            this.state.activeNodeId = id;
            this.state.lastMouse = { x: e.clientX, y: e.clientY };
            document.querySelectorAll('.canvas-node').forEach(n => n.classList.remove('selected'));
            const el = document.getElementById(`node-${id}`);
            if (el) el.classList.add('selected');
        },

        startResize(e, id) {
            e.preventDefault(); e.stopPropagation();

            // Force focus to container
            this.els.container.focus();

            this.state.preDragState = JSON.stringify(this.state.nodes);
            this.state.isResizing = true;
            this.state.activeNodeId = id;
            this.state.lastMouse = { x: e.clientX, y: e.clientY };
            document.body.style.cursor = 'nwse-resize';
        },

        parseCssVars(html) {
            const vars = {};
            const re = /(--[\w-]+)\s*:\s*([^;]+);/g;
            let m;
            while ((m = re.exec(html)) !== null) vars[m[1]] = m[2].trim();
            return vars;
        },

        updateIframe(id) {
            const node = this.state.nodes.find(n => n.id === id);
            if (!node || node.type !== 'snippet') return;
            const el = document.getElementById(`node-${id}`);
            const iframe = el.querySelector('iframe');
            
            let cssVars = ':root, body {';
            Object.entries(node.cssVars).forEach(([k,v]) => cssVars += `${k}: ${v};`);
            cssVars += '}';
            
            const baseCss = `body { margin: 0; padding: 0; overflow: hidden; font-family: sans-serif; height: 100vh; width: 100vw; } ::-webkit-scrollbar { display: none; }`;
            const fullCss = cssVars + baseCss;
            const fullSrc = `<style id="dynamic-vars">${fullCss}</style>${node.content}`;

            // Check if content structure changed (requires reload)
            if (iframe._lastRenderedContent !== node.content) {
                iframe.srcdoc = fullSrc;
                iframe._lastRenderedContent = node.content;
                return;
            }

            // If content is same, try live CSS update
            try {
                const doc = iframe.contentDocument;
                if (doc && doc.readyState === 'complete') {
                    let style = doc.getElementById('dynamic-vars');
                    if (style) {
                        style.textContent = fullCss;
                        // Important: Update srcdoc attribute silently so next reload (if any) is correct?
                        // Actually, updating srcdoc triggers reload. So we CANNOT update srcdoc attribute.
                        // We accept that srcdoc attribute is stale regarding CSS until next content change.
                        return;
                    }
                }
            } catch(e) { /* Fall through to reload */ }

            // If live update couldn't happen (e.g. style tag missing or doc not ready), reload.
            // Only reload if the src actually changed (to avoid loops)
            if (iframe.getAttribute('srcdoc') !== fullSrc) {
                iframe.srcdoc = fullSrc;
            }
        },

        updateNodeGlobalScale(id) {
            const el = document.getElementById(`node-${id}`);
            const scaler = el.querySelector('.iframe-scaler');
            const s = this.state.globalContentScale;
            if(scaler) {
                scaler.style.transform = `scale(${s})`;
                scaler.style.width = `${100/s}%`;
                scaler.style.height = `${100/s}%`;
            }
        },

        copyNodeCode(node) {
            let css = ':root, body {\n';
            Object.entries(node.cssVars).forEach(([k,v]) => css += `  ${k}: ${v};\n`);
            css += '}\n';
            const fullCode = `<style>\n${css}</style>\n${node.content}`;
            navigator.clipboard.writeText(fullCode).then(() => this.showToast('Code copied to clipboard!'));
        },

        setupUIEvents() {
            document.getElementById('btn-zoom-in').onclick = () => { 
                this.state.zoom = Math.min(5, this.state.zoom + 0.1); 
                this.renderTransform(); 
            };
            document.getElementById('btn-zoom-out').onclick = () => { 
                this.state.zoom = Math.max(0.1, this.state.zoom - 0.1); 
                this.renderTransform(); 
            };
            document.getElementById('btn-zoom-reset').onclick = () => this.resetZoom();

            document.getElementById('btn-theme').onclick = () => {
                this.state.theme = this.state.theme === 'light' ? 'dark' : 'light';
                this.loadTheme();
            };

            document.getElementById('btn-add-label').onclick = () => this.createLabelNode();
            document.getElementById('btn-undo').onclick = () => this.undo();
            
            const viewBtn = document.getElementById('btn-view-toggle');
            viewBtn.onclick = () => {
                const icon = document.getElementById('icon-view-toggle');
                const text = document.getElementById('text-view-toggle');
                
                if (this.state.viewMode === 'hover') {
                    this.state.viewMode = 'always';
                    document.body.classList.remove('details-on-hover');
                    document.body.classList.add('show-details-always');
                    icon.innerText = 'visibility';
                    text.innerText = 'Notes';
                } else {
                    this.state.viewMode = 'hover';
                    document.body.classList.remove('show-details-always');
                    document.body.classList.add('details-on-hover');
                    icon.innerText = 'visibility_off';
                    text.innerText = 'Notes';
                }
            };
            
            // Set initial state
            document.getElementById('text-view-toggle').innerText = 'Notes';
            document.getElementById('icon-view-toggle').innerText = 'visibility_off';

            // Dots Toggle
            document.getElementById('btn-dots-toggle').onclick = () => {
                document.body.classList.toggle('hide-dots');
                const icon = document.getElementById('icon-dots-toggle');
                if (document.body.classList.contains('hide-dots')) {
                    icon.innerText = 'grid_off';
                } else {
                    icon.innerText = 'grid_on';
                }
            };
            
            // --- Multi-Canvas Events ---
            
            document.getElementById('btn-save-canvas').onclick = () => this.saveCurrentCanvas();
            // document.getElementById('btn-new-canvas').onclick = () => this.createCanvas(); // Removed
            
            // Dropdown Toggle
            document.getElementById('canvas-menu-trigger').onclick = (e) => {
                e.stopPropagation();
                // Always toggle now
                this.els.canvasDropdown.classList.toggle('hidden');
                this.els.canvasDropdown.classList.toggle('flex');
            };
            
            // Title Rename (Blur)
            this.els.canvasTitle.onchange = (e) => {
                this.renameCanvas(e.target.value);
            };
            this.els.canvasTitle.addEventListener('mousedown', e => e.stopPropagation()); // Allow clicking input

            const slider = document.getElementById('global-scale-slider');
            const label = document.getElementById('global-scale-val');
            slider.oninput = e => {
                const val = parseFloat(e.target.value);
                this.state.globalContentScale = val;
                label.innerText = val.toFixed(1) + 'x';
                this.state.nodes.forEach(n => {
                    if(n.type === 'snippet') this.updateNodeGlobalScale(n.id);
                });
            };

            document.getElementById('btn-copy-all').onclick = () => {
                const data = JSON.stringify({ version: '3.0', nodes: this.state.nodes });
                navigator.clipboard.writeText(data).then(() => this.showToast('Canvas JSON Copied'));
            };

            document.getElementById('btn-paste-all').onclick = async () => {
                try {
                    const txt = await navigator.clipboard.readText();
                    const data = JSON.parse(txt);
                    if(data.nodes) {
                        this.loadCanvasState(data);
                        this.recordState();
                    }
                } catch(e) { this.showToast('Invalid JSON'); }
            };
            
            document.getElementById('btn-modal-close').onclick = () => this.closeModal();
            document.getElementById('btn-confirm-yes').onclick = () => this.confirmDelete();
            document.getElementById('btn-confirm-cancel').onclick = () => this.closeConfirm();
            
            // Close dropdown if clicked outside
            window.addEventListener('click', () => {
                this.els.canvasDropdown.classList.add('hidden');
                this.els.canvasDropdown.classList.remove('flex');
            });
        },

        loadTheme() {
            const root = document.documentElement;
            if(this.state.theme === 'dark') root.classList.add('dark');
            else root.classList.remove('dark');
            document.getElementById('btn-theme').innerHTML = `<span class="material-symbols-outlined text-[24px]">${this.state.theme === 'dark' ? 'light_mode' : 'dark_mode'}</span>`;
            if(this.editor && window.monaco) {
                monaco.editor.setTheme(this.state.theme === 'dark' ? 'vs-dark' : 'vs');
            }
        },

        openModal(node) {
            const previewEl = document.getElementById(`node-${node.id}`).querySelector('.node-preview-wrapper');
            this.state.activeModalNodeId = node.id;

            const updateDom = () => {
                this.els.modal.classList.remove('hidden');
                
                // Content
                let css = ':root, body {';
                Object.entries(node.cssVars).forEach(([k,v]) => css += `${k}: ${v};`);
                css += '}';
                
                // Iframe
                this.els.modalIframe.srcdoc = `<style>${css} html, body { margin: 0; padding: 0; height: 100%; width: 100%; font-family: sans-serif; display: block; }</style>${node.content}`;
                
                // Code
                const fullCode = `<style>\n${css}</style>\n${node.content}`;
                if(this.editor) {
                    this.editor.setValue(fullCode);
                    this.editor.setScrollTop(0);
                }
                
                // Setup Copy Button (Snippet)
                document.getElementById('btn-modal-copy').onclick = () => {
                     navigator.clipboard.writeText(fullCode).then(() => this.showToast('Snippet copied!'));
                };

                // Setup Copy Button (Full HTML)
                document.getElementById('btn-modal-copy-top').onclick = () => {
                     const html = `<!DOCTYPE html>\n<html>\n<head>\n<style>\n${css}</style>\n</head>\n<body>\n${node.content}\n</body>\n</html>`;
                     navigator.clipboard.writeText(html).then(() => this.showToast('Full HTML copied!'));
                };
            };

            if (document.startViewTransition) {
                previewEl.style.viewTransitionName = 'modal-expand';
                
                const transition = document.startViewTransition(() => {
                    previewEl.style.viewTransitionName = ''; 
                    document.getElementById('modal-content').style.viewTransitionName = 'modal-expand';
                    updateDom();
                });

                transition.finished.then(() => {
                    document.getElementById('modal-content').style.viewTransitionName = '';
                    if(this.editor) this.editor.layout();
                });
            } else {
                updateDom();
            }
        },

        closeModal() {
            const modalContent = document.getElementById('modal-content');
            const previewEl = this.state.activeModalNodeId ? document.getElementById(`node-${this.state.activeModalNodeId}`)?.querySelector('.node-preview-wrapper') : null;

            const updateDom = () => {
                this.els.modal.classList.add('hidden');
                this.els.modalIframe.srcdoc = '';
            };

            if (document.startViewTransition && previewEl) {
                modalContent.style.viewTransitionName = 'modal-expand';
                
                const transition = document.startViewTransition(() => {
                    modalContent.style.viewTransitionName = '';
                    previewEl.style.viewTransitionName = 'modal-expand';
                    updateDom();
                });

                transition.finished.then(() => {
                    previewEl.style.viewTransitionName = '';
                });
            } else {
                updateDom();
            }
            this.state.activeModalNodeId = null;
        },

        showToast(msg) {
            const t = this.els.toast;
            t.innerText = msg;
            t.style.opacity = 1;
            t.style.transform = 'translate(-50%, 0)';
            setTimeout(() => {
                t.style.opacity = 0;
                t.style.transform = 'translate(-50%, 16px)';
            }, 2000);
        }
    };

    document.addEventListener('DOMContentLoaded', () => App.init());
</script>

</body></html>